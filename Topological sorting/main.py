def topological_sort(elements, matrix):
    n = len(elements)

    graph = {key: [] for key in elements} 
    # graph - це словник, де keys - це елементи, що містяться у списку elements, а значення початково встановлені як порожні списки.
    for i in range(n): # i - рядок
        for j in range(n): # j - стовпець
            if matrix[i][j] == 1:
                graph[elements[i]].append(elements[j]) # Якщо 1 то додає новий елемент elements[j] до списку сусідніх вершин для вершини elements[i]

    visited = {key: False for key in elements} # Використовуємо для відстеження того, чи була відвідана кожна вершина графа
    sort_list = [] # Створюємо порожній список для того щоб потім зберігати вершини у відсортованому порядку
    stack = []  # Додаємо стек для перевірки на ациклічність

    # У функції нижче, node є поточною вершиною, для якої виконується операція пошуку в глибину (DFS). 
    # Під час виконання DFS, вершини обходяться одна за одною, і кожна з них стає поточною вершиною для обробки.
    def dfs(node):
        visited[node] = True # Позначаємо вершину 'node' як відвідану
        stack.append(node) # Додаємо поточну вершину у стек для перевірки ациклічності
        for neighbor in graph[node]:
            # Перевіряємо чи вершина neighbor вже відвідана та перевіряємо ациклічність
            if not visited[neighbor]:
                if dfs(neighbor):
                    return True
            elif neighbor in stack: # Якщо сусідню вершину вже є у стеці, то є цикл
                return True
        stack.remove(node) # Після обробки вершини, видаляємо її зі стеку
        sort_list.append(node)

    # Визиваємо функцію для кожної вершини щоб відсортувати потім наші елементи
    for node in elements:
        if not visited[node]:
            if dfs(node):
                return None  # Повертаємо None, якщо граф має цикл

    # І нарешті повертаємо наш список у зворотньому порядку
    if sort_list:
        return sort_list[::-1] 
    else:
        None  # Повертаємо None, якщо список порожній (граф складається з однієї вершини)  
#########################################################
#1 Граф
# Елементи, які вказані на самому малюнку
elements1 = ['1', '2', '3', '4', '5', '6']
# Приклад використання через матрицю суміжності:
graph1_matrix = [
    [0, 1, 0, 0, 0, 0],
    [0, 0, 1, 0, 1, 1],
    [0, 0, 0, 0, 0, 0],
    [1, 0, 0, 0, 0, 0],
    [0, 0, 0, 1, 0, 0],
    [0, 0, 0, 0, 0, 0]
]
#graph1
#      1  2  3  4  5  6
#      ________________
# 1   |0  1  0  0  0  0
# 2   |0  0  1  0  0  1
# 3   |0  0  0  0  0  0
# 4   |1  0  0  0  1  0
# 5   |0  1  0  0  0  0
# 6   |0  0  0  0  0  0

#####################################################
#2 Граф
# Елементи, які вказані на самому малюнку
elements2 = ['Очки', 'Шкарпетки', 'Взуття', 'Брюки', 'Кофта', 'Жакет', 'Пальто']
# Приклад використання через матрицю суміжності:
graph2_matrix = [
    [0, 0, 0, 0, 0, 0, 0],
    [0, 0, 1, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0],
    [0, 0, 1, 0, 0, 1, 1],
    [0, 1, 0, 0, 0, 1, 0],
    [0, 0, 0, 0, 0, 0, 1],
    [0, 0, 0, 0, 0, 0, 0]
]
#graph2
#      О  Ш  В  Б  К  Ж  П  
#      ___________________
# О   |0  0  0  0  0  0  0  
# Ш   |0  0  1  0  0  0  0  
# В   |0  0  0  0  0  0  0  
# Б   |0  0  1  0  0  1  1  
# К   |0  1  0  0  0  1  0  
# Ж   |0  0  0  0  0  0  1  
# П   |0  0  0  0  0  0  0 

######################################################
sorted_vertices1 = topological_sort(elements1, graph1_matrix)
print("Result:", sorted_vertices1)

sorted_vertices2 = topological_sort(elements2, graph2_matrix)
print("Result:", sorted_vertices2)